# Adding Entity Framework Core Support to a Web API

## Adding Entity Framework Dependencies

1. Start with the application created in Lab 8
1. Runtime Entity Framework Core packages (`Microsoft.EntityFramework.*`) are 
already included in your project thanks to the 
[`Microsoft.AspNetCore.All`](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/metapackage) 
metapackage dependency
1. Make Entity Framework Core commands available to the .NET CLI by adding 
the following `ItemGroup` item to you .csproj:
    ```xml
    <ItemGroup>
      <DotNetCliToolReference Include="Microsoft.EntityFrameworkCore.Tools.DotNet" Version="2.0.0" />
    </ItemGroup>
    ```
1. Open a command prompt and (from the directory your csproj is in) run:
`dotnet ef`

## Setup our Entity Framework Model

Entity Framework models can be either [code-first](https://docs.microsoft.com/en-us/ef/core/get-started/aspnetcore/new-db) 
or [database-first](https://docs.microsoft.com/en-us/ef/core/get-started/aspnetcore/existing-db). 
For now, we will create the model in code first.

1. Create a new class called `Order` in the *Models* folder:
    ```CSharp
    public class Order
    {
        public int Id { get; set; }
        public string Description { get; set; }
        public ICollection<Product> Items { get; set; }
        public DateTime DateCreated { get; set; }
        public bool Completed { get; set; }
    }
    ```
1. Many-to-many relationships need to be modeled with an explicit join table 
in Entity Framework Core (for now; making this easier is on 
[the backlog](https://github.com/aspnet/EntityFrameworkCore/issues/1368)). To 
enable a many-to-many relationship between `Product` and `Order` entities, 
create a join type called `OrderItem`.
    ```CSharp
    public class OrderItem
    {
        public int Id { get; set; }
        public Order Order { get; set; }
        public Product Product { get; set; }
    }
    ```
1. Update the `Order` class to add an `ICollection` of `OrderItem`s, make
`Items`'s getter return values from `OrderItems`, and mark `Items` as 
`[NotMapped]`, 
make it
    ```CSharp
    public ICollection<OrderItem> OrderItems { get; set; } = new HashSet<OrderItem>();

    [NotMapped]
    public IEnumerable<Product> Items => OrderItems.Select(o => o.Product);
    ```
1. Update the `Product` class to have (a `[NotMapped]`) Orders property and 
an `IEnumerable<OrderItem>` that returns orders from `OrderItems`
    ```CSharp
    public ICollection<OrderItem> OrderItems { get; set; } = new HashSet<OrderItem>();

    [NotMapped]
    public IEnumerable<Order> Orders => OrderItems.Select(o => o.Order);    
    ```
1. Create a DbContext class (`OrdersContext`) in a new folder called *Data* 
to serve as the 'connection' class that Entity Framework Core uses to map 
database tables to .NET classes:
    ```CSharp
    public class OrdersContext : DbContext
    {
        public OrdersContext(DbContextOptions<OrdersContext> options)
            : base(options)
        { }

        public DbSet<Order> Orders { get; set; }
        public DbSet<Product> Products { get; set; }
        public DbSet<OrderItem> OrderItems { get; set; }

        /// <summary>
        /// This method can be used to customize ORM beahviors
        /// </summary>
        /// <param name="modelBuilder"></param>
        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            // For example, table names for .NET classes can be customized
            modelBuilder.Entity<Order>().ToTable("Order");
            modelBuilder.Entity<Product>().ToTable("Product");
            modelBuilder.Entity<OrderItem>().ToTable("OrderXProduct");

            // Or, relationships between entities could be explicitly defined
            // or keys could be defined, etc.
        }
    }
    ```
1. Make the DbContext (`OrdersContext`) available to your app by registering 
it in the dependency injection container (by adding the following code to 
`ConfigureServices` in *Startup.cs*)
    ```CSharp
    services.AddDbContext<OrdersContext>(contextOptions =>
        contextOptions.UseInMemoryDatabase("ordersDb"));
    ```

## Seed the Database
At this point, necessary infrastructure is in place to read and write entity 
data from a database. We don't have anything in the database, though, so 
let's create a seed method that will populate the database with test data 
if it doesn't exist yet.

1. Create a new static `DbInitializer` class in a new file in the *Data* 
folder
1. In that class, create a static method called `Initialize` to create 
the app's database (if it doesn't exist) and to populate it with initial 
data (if it's empty).
    ```CSharp
    public static void Initialize(OrdersContext context)
    {
        // Creates the database if it doesn't exist
        context.Database.EnsureCreated();

        // Checks to see if any products exist
        if (context.Products.Any())
        {
            return;   // DB already has been seeded
        }

        // Initial products
        var products = new Product[]
        {
            new Product{ Name = "Widget 1.0" },
            new Product{ Name = "Super Widget" },
            new Product{ Name = "Widget Mini" },
            new Product{ Name = "Widget Xtreme" },
            new Product{ Name = "Jumbo Widget" },
            new Product{ Name = "Widget 2.0" }
        };

        context.Products.AddRange(products);
        context.SaveChanges();

        // Initial orders
        var orders = new Order[]
        {
            new Order{ Description = "First order", DateCreated = DateTime.Now.AddDays(-10), Completed = true },
            new Order{ Description = "Second order", DateCreated = DateTime.Now }
        };

        context.Orders.AddRange(orders);
        context.SaveChanges();

        // Initial order x product joins
        var orderItems = new OrderItem[]
        {
            new OrderItem{ Order = orders[0], Product = products[0]},
            new OrderItem{ Order = orders[0], Product = products[3]},

            new OrderItem{ Order = orders[0], Product = products[1]},
            new OrderItem{ Order = orders[0], Product = products[3]},
            new OrderItem{ Order = orders[0], Product = products[5]},
        };

        context.OrderItems.AddRange(orderItems);
        context.SaveChanges();
    }
    ```
1. Update `Main` in *Program.cs* to invoke the DbInitializer
    ```CSharp
    var host = BuildWebHost(args);

    using (var scope = host.Services.CreateScope())
    {
        var services = scope.ServiceProvider;
        try
        {
            var context = services.GetRequiredService<OrdersContext>();
            DbInitializer.Initialize(context);
        }
        catch (Exception ex)
        {
            var logger = services.GetRequiredService<ILogger<Program>>();
            logger.LogError(ex, "An error occurred while seeding the database.");
        }
    }

    host.Run();
    ```

## Update the App to use the DbContext


## Scaffold 

## Database migrations