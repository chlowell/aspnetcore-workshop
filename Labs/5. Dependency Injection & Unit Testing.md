# Using Dependency Injection to register and resolve application services

## Creating a service to assign request IDs
1. Create a new application using the ASP.NET Core Web Application **Web Api** template
1. Create a folder in the application called `Services`
1. In the new folder, create an interface `IRequestIdFactory` with a single method `string MakeRequestId()`
1. In the same file, create a class `RequestCounter` which implements `IRequestIdFactory`, using `Interlock.Increment` to count requests.
1. The file should look something like this:

  ```cs
    using System.Threading;

    namespace Lab5.Services
    {
        public interface IRequestIdFactory
        {
            string MakeRequestId();
        }

        public class RequestCounter : IRequestIdFactory
        {
            private int _requestId;

            public string MakeRequestId() => Interlocked.Increment(ref _requestId).ToString();
        }
    }
  ```

## Register the request ID service in DI container
1. In the application's `Startup.cs` file, find the `ConfigureServices(IServiceCollection services)` method.
1. Register the `IRequestIdFactory` service as a singleton: `services.AddSingleton<IRequestIdFactory, RequestCounter>();`
1. The `ConfigureServices` method should now look like this:

  ```cs
  public void ConfigureServices(IServiceCollection services)
  {
      services.AddSingleton<IRequestIdFactory, RequestCounter>();
      services.AddMvc();
  }
  ```

## Add middleware that logs request IDs
1. Create a new folder in the application named `Middleware`
1. In the new folder, create a class `RequestIdMiddleware`
1. Create a constructor `public RequestIdMiddleware(RequestDelegate next, IRequestIdFactory requestIdFactory, ILogger<RequestIdMiddleware> logger)` which stores its parameters in private fields.
1. Add a method `public Task Invoke(HttpContext context)` which logs the request ID using the `ILogger` and `IRequestIdFactory` injected to the constructor.
1. The class should look something like this:

  ```cs
    using Microsoft.AspNetCore.Http;
    using Microsoft.Extensions.Logging;
    using System.Threading.Tasks;

    namespace Lab5.Middleware
    {
        public class RequestIdMiddleware
        {
            private readonly RequestDelegate _next;
            private readonly ILogger<RequestIdMiddleware> _logger;
            private readonly IRequestIdFactory _requestIdFactory;

            public RequestIdMiddleware(RequestDelegate next, IRequestIdFactory requestIdFactory, ILogger<RequestIdMiddleware> logger)
            {
                _next = next;
                _logger = logger;
                _requestIdFactory = requestIdFactory;
            }

            public Task Invoke(HttpContext context)
            {
                _logger.LogInformation($"Request {_requestIdFactory.MakeRequestId()} executing.");

                return _next(context);
            }
        }
    }
  ```

6. Add the middleware to the pipeline in `Startup.cs` by calling `app.UseMiddleware<RequestIdMiddleware>()` before the call to `app.UseMvc()`:

  ```cs
    if (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
    }

    app.UseMiddleware<RequestIdMiddleware>();

    app.UseMvc();
  ```

7. Run the application. You should see the logging messages from the middleware in the console output.

# Unit testing

## Adding basic tests

1. Right-click on the solution and select Add -> New Project -> Unit Test Project
1. In the new test project, add a reference to the Lab 5 project.
1. Rename `UnitTest1.cs` to `RequestCounterTests.cs`
1. Write a basic test for `RequestCounter`. For example:

```cs
    [TestClass]
    public class RequestCounterTests
    {
        [TestMethod]
        public void RequestIdIsIncreasingInt()
        {
            var factory = new RequestCounter();

            var first = int.Parse(factory.MakeRequestId());
            var second = int.Parse(factory.MakeRequestId());

            Assert.IsTrue(second == first + 1);
        }
    }
```

## Extending ValuesController

Dependency injection makes unit testing easier and more powerful. To see how, let's first extend the `ValuesController` with a dependency.

1. Add `ValuesService.cs` to the lab project's `Services` folder. Define an `IValuesService` interface with a single method, `IEnumerable<string> GetValues()`

1. Add a `DefaultValuesService` implementation to the file. Have it return the project template's default values:

```cs
    public interface IValuesService
    {
        IEnumerable<string> GetValues();
    }

    public class DefaultValuesService : IValuesService
    {
        public IEnumerable<string> GetValues() => new[] { "value1", "value2" };
    }
```

3. Register the `DefaultValuesService` as a scoped `IValuesService` in `Startup.cs`:

```cs
    public void ConfigureServices(IServiceCollection services)
    {
        services.AddScoped<IValuesService, DefaultValuesService>();
        services.AddSingleton<IRequestIdFactory, RequestCounter>();
        services.AddMvc();
    }
```

4. Add a constructor to `ValuesController` which requests an `IValuesService` and stores it in a field.

1. Alter the controller's parameterless GET route to return values from the service. Your `ValuesController` should now contain code like this:

```cs
    private readonly IValuesService _valuesService;

    public ValuesController(IValuesService valuesService)
    {
        _valuesService = valuesService;
    }

    // GET api/values
    [HttpGet]
    public IEnumerable<string> Get()
    {
        return _valuesService.GetValues();
    }
```

6. Run the application. When you browse to the /api/values route, you should see the default values returned.

## Unit testing ValuesController

1. Add a `ValuesControllerTests` class to the unit test project.

1. Write an implementation of `IValuesService` which returns test strings.

1. Write a test which creates a new `ValuesController` using the test `IValuesService`
 and validates that its `Get()` method returns the expected test strings. For example:

```cs
    [TestClass]
    public class ValuesControllerTests
    {
        [TestMethod]
        public void GetReturnsExpectedStrings()
        {
            var controller = new ValuesController(new TestValuesService());

            var result = controller.Get();

            Assert.AreEqual(result.Count(), TestStrings.Count());
            Assert.IsTrue(result.All(v => TestStrings.Contains(v)));
        }

        private static IEnumerable<string> TestStrings => new[] { "test string 1", "test string 2" };

        private class TestValuesService : IValuesService
        {
            public IEnumerable<string> GetValues() => TestStrings;
        }
    }
```

## Extra

1. Use a library like `NSubstitute` or `Moq` to replace the test `IValuesService` with a mock.